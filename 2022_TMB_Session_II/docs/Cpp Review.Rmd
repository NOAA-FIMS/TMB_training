---
title:  "C++ Review"
subtitle: "TMB Training Session II"
author: "Andrea Havron<br>NOAA Fisheries, OST"
output:
  xaringan::moon_reader:
    self_contained: true
    css: ["xaringan-themer.css", "slides-style.css"]
    lib_dir: libs
    nature:
      ratio: '16:9'
      highlightStyle: github
      highlightLines: true
      countIncrementalSlides: false
      slideNumberFormat: |
        <div class="progress-bar-container">
          <div class="progress-bar" style="width: calc( (%current% - 1) / (%total% - 1) * 100%);">
          </div>
        </div>`
---
layout: true

.footnote[U.S. Department of Commerce | National Oceanic and Atmospheric Administration | National Marine Fisheries Service]


<style type="text/css">

code.cpp{
  font-size: 14px;
}
code.r{
  font-size: 14px;
}


</style>


```{r setup, include=FALSE}
options(htmltools.dir.version = FALSE)
```

```{r xaringan-tile-view, echo=FALSE}
# this gives you a tile navigation if you type "O" at any time
xaringanExtra::use_tile_view()
```

---
# C++ and Memory


.column-60[
C++ code
```{Rcpp, eval = FALSE}
#include <iostream>

int main() {
  //initiate a variable
  float a = 3.1459;
  //initiate a new variable with the same value as a
  float b = a;
  //initiate a variable c that points to the same address as a
  float* c = &a;
  std::cout << "c is equal to the address of a; *c = a" << std::endl;
  std::cout << "c = " << c << std::endl;
  std::cout << "a = " << a << "; *c = " << *c << std::endl;
  return 0;
}
```
]

.column-40-left[
Console output
```{r, eval = FALSE}
g++ memoryexample.cpp -o a.exe
a.exe

c is equal to the address of a; *c = a
c = 0x78fe14
a = 3.1459; *c = 3.1459
```
]

---
# C++ and Memory

.column-60[
C++ code
```{Rcpp, eval = FALSE}
#include <iostream>

int main() {
  //initiate a variable
  float a = 3.1459;
  //initiate a new variable with the same value as a
  float b = a;
  //initiate a variable c that points to the same address as a
  float* c = &a;
  *c = 100;
  std::cout << "a and *c have been updated; b has not"  << std::endl;
  std::cout << "a = " << a << "; *c = " << *c << std::endl;
  std::cout << "b = " << b << std::endl;
  return 0;
}
```
]

.column-40-left[
Console output
```{r, eval = FALSE}
g++ memoryexample.cpp -o a.exe
a.exe

a and *c have been updated; b has not
a = 100; *c = 100
b = 3.1459
```
]
---
# C++ and Memory

.column-60[
C++ code
```{Rcpp, eval = FALSE}
#include <iostream>

int main() {
  //initiate a variable
  float a = 3.1459;
  //initiate a new variable with the same value as a
  float b = a;
  //initiate a variable c that points to the same address as a
  float* c = &a;
  *c = 100;
  c = &b;
  b = 10;
  a = 3;
  std::cout << "c now equals the address of b" << std::endl;
  std::cout << "c = " << c << "; &b = " << &b << std::endl;
  std::cout << "a = " << a << std::endl;
  std::cout << "b = " << b << std::endl; 
  std::cout << "*c = " << *c ;
  return 0;
}
```
]

.column-40-left[
Console output
```{r, eval = FALSE}
g++ memoryexample.cpp -o a.exe
a.exe

c now equals the address of b
c = 0x78fe10; &b = 0x78fe10
a = 3
b = 10
 *c = 10
```
]
---
# Update values using pointers

.column-60[
C++ code
```{Rcpp, eval = FALSE}
#include <iostream>
#include <cmath>

template <class T>
  T my_add(T *x, T y){
    *x += y;
    return 0;
}
template <class T>
  T my_exp(T *x){
    *x = std::exp(*x);
    return 0;
}
int main() {
  //initiate a variable
  float par = 0;
  //initiate a new constant used to update par
  float b = 0.6931472;
  //intiate a pointer to par
  float *c = &par;
  //update par using functions
  my_add(c, b);
  std::cout << "par = " << par << std::endl;
  my_exp(c);
  std::cout << "par = " << par << std::endl;
  return 0;
}
```
]

.column-40-left[
Console output
```{r, eval = FALSE}
g++ pointerexample.cpp -o a.exe
a.exe

par = 0.6931472
par = 2
```
]

---
# C++ Anatomy of a Class

```cpp
class ClassName{
  Access specifier: //can be private, public, or protected
  Data members; //variables to be used
  
  ClassName(){} //Constructor - automatically called when new object created
  
  Member functions(){} //Methods to access data members
  
}; //class name ends with semicolon


//create instance of class
ClassName<T>* ClassName<T>::instance = new ClassName<T>();

```
.p[
- Memory is not allocated when a class is defined
- An instance of the class needs to be created for memory allocation (new object created)
- **new** is the C++ initialize function that allocates memory
- Once the class is instantiated, members can be accessed using the dot('.')
]
resources:<br>
[**geeksforgeeks**](https://www.geeksforgeeks.org/c-classes-and-objects/)<br>
[**cplusplus**](https://cplusplus.com/doc/tutorial/classes/)
---
# Class Example

C++ code
.pull-left[
```{Rcpp, eval = FALSE}
#include <iostream>

template <class T>
class MyClass{
    public:
    T a;
    T b;
    MyClass(){}
    T evaluate(){
        return a + b;
    }
};
int main() {
  //initiate class
  MyClass<double> *m = new MyClass<double>();
  m -> a = 1.2;
  m -> b = 3.4;
  std::cout << m -> evaluate() << std::endl;  
  //intiate class
  MyClass<double> myclass;
  myclass.a = 2;
  myclass.b = 3;
  std::cout << myclass.evaluate() << std::endl;
  return 0;
}
```
]
.pull-right[
Console output
```{r, eval = FALSE}
g++ classexample.cpp -o a.exe
a.exe

4.6
5
```
]
---
# TMB and FIMS
[**fimsflow**](https://docs.google.com/presentation/d/1U8N6J6YQIdd0Wer-o5vZvGTHgw1GLA8_6a0r8sYfqXo/edit#slide=id.g13fa6bc6e99_0_0)
```{r, echo = FALSE, out.width="60%", fig.align="left"}
knitr::include_graphics("static/fims-tmb1.png")
```
---
# TMB and FIMS
[**fimsflow**](https://docs.google.com/presentation/d/1U8N6J6YQIdd0Wer-o5vZvGTHgw1GLA8_6a0r8sYfqXo/edit#slide=id.g1405a9bb7f8_0_0)
```{r, echo = FALSE, out.width="80%", fig.align="left"}
knitr::include_graphics("static/fims-tmb2.png")
```
---

# Modular TMB structure: C++ code
.pull-left[
Common.hpp - setup TMB dependencies and define data types
```{Rcpp, eval = FALSE}
#include <TMB.hpp>
using namespace tmbutils;
using namespace density;
//#include "tmbutils_extra.hpp"
//#include <Rcpp.h>
//using namespace Rcpp;

template<typename Type>
struct model_traits{
 typedef typename CppAD::vector<Type> data_vector;
 typedef data_indicator<tmbutils::vector<Type> , Type>  data_indicator;
 typedef typename tmbutils::array<Type> array;
};
```
]
.pull-right[
```{Rcpp, eval = FALSE}
#include "Common.hpp"
template<class Type>
class ar1xar1{
  
  using DataVector = typename model_traits<Type>::data_vector;
  using DataIndicator = typename model_traits<Type>::data_indicator;
  using ParameterArray = typename model_traits<Type>::array
  
  public:
  DataVector  y;
  DataIndicator keep;

  ParameterArray eta;
  Type phi1;
  Type phi2;
  static ar1xar1<Type>* instance;
  
  ar1xar1(){}
  
  static ar1xar1<Type>* getinstance(){
    return ar1xar1<Type>::instance;
  }
  
  ...
```
  ]
---
# Modular TMB structure: C++ code
.pull-left[
Common.hpp - setup TMB dependencies and define data types
```{Rcpp, eval = FALSE}
#include <TMB.hpp>
using namespace tmbutils;
using namespace density;
//#include "tmbutils_extra.hpp"
//#include <Rcpp.h>
//using namespace Rcpp;

template<typename Type>
struct model_traits{
 typedef typename CppAD::vector<Type> data_vector;
 typedef data_indicator<tmbutils::vector<Type> , Type>  data_indicator;
 typedef typename tmbutils::array<Type> array;
};
```
]
.pull-right[
```{Rcpp, eval = FALSE}
#include "Common.hpp"
template<class Type>
class ar1xar1{
  ...
  Type evaluate(){
    Type nll = 0;
    vector<Type> ln_lambda(y.size());
    nll += SEPARABLE( AR1(phi2), AR1(phi1) )(eta);
    for(int i=0; i < y.size(); i++){
      nll -= keep[i] * dpois(y[i], exp(eta[i]), true);
      Type cdf = squeeze( ppois(y[i], exp(eta[i])) );
      nll -= keep.cdf_lower[i] * log( cdf );       // NaN protected
      nll -= keep.cdf_upper[i] * log( 1.0 - cdf ); // NaN protected
    }

    return nll;
  }

};
template<class Type>
ar1xar1<Type>* ar1xar1<Type>::instance = new ar1xar1<Type>();
```
]
---
# Modular TMB structure: TMB model
```{Rcpp, eval = FALSE}
template<class Type>
Type objective_function<Type>::operator() ()
{

  ar1xar1<Type>* inst = ar1xar1<Type>::getinstance();
  
  DATA_VECTOR(y); 
  DATA_VECTOR_INDICATOR(keep,y);
  PARAMETER_ARRAY(eta);
  PARAMETER(transf_phi1); Type phi1 = f(transf_phi1);
  PARAMETER(transf_phi2); Type phi2 = f(transf_phi2);
  
  inst->y = y;
  inst->keep = keep;
  inst->phi1 = phi1;
  inst->phi2 = phi2;
  inst->eta = eta;
  
  Type nll = inst -> evaluate();

  SIMULATE{
    SEPARABLE(AR1(phi2), AR1(phi1)).simulate(eta);
    vector<Type> ln_lambda = eta;//convert array to vector for rpois simulation
    y = rpois(exp(ln_lambda));//rpois cannot accept array 
    REPORT(eta);
    REPORT(y);
  }
  ADREPORT(phi1);
  ADREPORT(phi2);

  return nll;
}
```